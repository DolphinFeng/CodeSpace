v-for的key此前是index，但是其实不建议使用这个作key

# 虚拟dom
1. 虚拟dom是vue中的编译器，将模板代码编译成对象
修改ul的某个li时，有两种方案，一个是全部修改，修改整个dom，另一个针对修改，按道理后者更好，重新编译耗时在编译器的执行，但是yyx取了前者，后者得话又需要一个方法，去查找哪个地方发生了变更，这个方法很难写，变更的数据源，很难找。所以直接生成一份新的dom, newDom。这样就有了一份新的虚拟dom结构；当年第一次虚拟dom，编译器又得把它生成原生html代码。所以之前是模板代码被编译器读成了一个虚拟dom，然后编译器又将这个虚拟dom编译成原生html。后面的环节是浏览器的render了，接下来因为你改变了数据源，编译器需要重新编译，形成newDom，又编译成一份html，然后页面就更新了。问题来了，编译的工作是给v8干的，render就涉及回流重绘问题，回流就是布局计算，重绘就是绘制出来，这样就会浪费很多性能，只有第三个li需要动。对于v8的编译是绰绰有余，这个时候一定需要用后者的办法，所以此时不是生成一份新的html，拿到新的dom和旧的dom进行对比，这个找法其实也有点难度，找不同就是diff算法，找到不同的地方之后记录下来，diff过程会得到一个新的产物，这个东西是个补丁包path，这个补丁包拿去旧的html结构中去修改，这个过程就会大大降低回流重绘的开销

回流对浏览器来说性能开销是非常大的，所以此时必须要用后者方法

# diff
全称different。
1. 将新老 VDom 的不同点 找到并生成一个补丁 补丁包其实是一个对象
面试官：diff的查找过程是什么/ diff的原理是什么
原理只要阐述出来即可，代码会很复杂
- 过程
1. 同层比较，是不是相同的节点，不相同直接废弃oldDom // 直接废弃和想要保存相同的又要对比，复杂程度指数级增长
2. 是相同节点，比较节点上的属性，产生一个补丁包path
3. 继续比较子节点下一层的子节点，采用双端队列的方式，尽量复用，产生一个补丁包
4. 同上

# vue中为什么不建议使用index作为key
- 为什么要有key?
让diff比较时比较的效率更高

- 为什么不能用index?
因为index是数组下标，下标永远是固定的位置，从0开始，哪怕数据只是发生了位置变更，key就会不一样，就会导致原本可以复用的节点，需要重新被认定为不可复用，浪费渲染性能

- 可不可以用随机数作key?
不可以，每次都会变化，比如反转后key值又变了，又不同了