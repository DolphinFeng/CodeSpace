// 这种面试题网上一大堆
// 合格的前端工程师可以回答得很全面
12.27 先讲  下
上：
输入baidu.com 可以看到百度首页，发生了很多事情：
    电脑首先要清楚url的服务器在哪里，去要数据：1. 谁告诉你服务器在北京的（dns解析，也就是域名解析，通过ip协议定位，自己的ip和服务器的ip进行传输）  2.三次握手，进行连接，四次握手，断开连接 报文  http马上到3.0版本 
    前后端分离式：前端代码一般都部署在服务器，然后用户触发ajax请求  
    前后端不分离式：jsp，写在java
# 浏览器加载到了资源  
结构由html说了算
1. 解析html代码，生成一个dom树
    dom树：html结构，树是一种数据结构，js用对象表达树这种结构 且看test.html
2. 解析css，生成CSSOM树
3. 将dom树和cssOM树结合，**去除不可见的元素**，生成Render Tree   // display: none 就不会参与进render tree
    GPU理解成一个画笔，控制物理发光点亮与不亮，以及颜色，绘制之前还需要算好容器的坐标
4. 计算布局，根据Render Tree 进行布局的计算，得到每一个节点的几何信息  让我想起 getBoundaryClientReset 
5. 绘制页面，GPU根据布局信息绘制效果

我们着重看4和5
计算布局我们称之为回流|重排  绘制页面称之为重绘
前三个步骤无法优化，不过css可以优化 且看test.html 不过css性能开销不大，比起dom树微乎其微，对于步骤三，如果dom树，cssOM树很清晰，就没啥好优化的


# 回流
浏览器计算页面布局的过程叫做回流
只要页面有容器的变更就需要回流，因为会影响它的排版，GPU要重新计算布局
脱离文档流的容器变更不会影响回流，只需要计算那一个容器的回流，不会全局回流
所以回流太常见了，
1. 改变窗口的尺寸，
2. 改变元素尺寸，
3. display: none；（增加删除可见元素）
4. 页面初次渲染，

# 重绘
将已经计算好布局的容器在屏幕上亮起来
回流需要的算力更多，因为要计算，重绘仅仅就是上色
元素的非几何属性变化时，会发生重绘
1. 修改背景颜色
2. 修改背景图片
3. 边框颜色
4. 字体颜色
5. 回流

回流一定会重绘  但是重绘不一定会回流

# 如何减少回流，重绘
1. 合理利用浏览器的优化策略
2. 先display: none; 修改完样式后，再block回来


# 浏览器的优化策略
当代浏览器都有一个渲染队列机制，改变一个容器的样式，导致需要发生回流的时候，这个操作会进入渲染队列，如果还有相同行为，继续进入队列，直到下面没有样式修改，浏览器会批量化地执行渲染队列中的回流过程，这只发生一次回流

offsetWidth, offsetHeight, offsetTop, offsetLeft 
clientWidth, clientHeight, clientTop, clientLeft // 和off是一样的，只是不包含边框
scrollWidth, scrollHeight, scrollTop, scrollLeft 
上面这些属性都会导致浏览器的渲染队列强制执行
如果队列满了就会强制执行一次，再重新入队


