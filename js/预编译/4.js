//如果不止函数体呢？
//1.全局的预编译
// GO: {
//     global: undefined
//     fn: function (fn) {}
// }
// 2.GO: {
//     global: 100
// }

var glogal = 100
function fn(){
    console.log(glogal)
}
// 3.AO: {

// }
// globl先在AO找，后在GO找
fn()
//面试官为你为什么打印100，你回答从内到外找，没到点上，为什么作用域可以从内到外
//上下文对象
//底层逻辑
        // 栈是一种数据结构，可以理解为数组-----调用栈-----（存放各种规则），
        // 全局执行上下文先进去在栈底部，全局执行上下文有两类（变量环境（GO内容,var变量的声明，global = undefined，fn = func），词法环境（V8以前没有，专门用来放let和const变量，目的就是声明不提升））
        // 然后开始执行，global = 100,fn 的调用，开始
        // 函数执行上下文AO，也有自己的变量环境，词法环境(目前都是空的)，这个上下文在全局上下文上面
        // 调用栈有个指针，指向现在哪个上下文在执行，先在函数执行上下文找词法环境，后在变量环境，指针（指向谁就是找谁），找不到指针下移
        // 在全局执行上下文，先找词法环境，后找变量环境，都是这个规则
        // 符合栈的数据结构，一口井，先进后出，取上之后才能取下
        // 数组是有两个口子
        