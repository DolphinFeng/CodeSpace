let obj = {
    name: '小黑子'
}
// 这个对象占据全局执行上下文，词法中有这个地址，这行代码执行完毕(后面也没人用的时候)，obj要被清理掉
// js垃圾回收机制是自动的，C语言需要手动释放，所以C语言很难写

//这是普通引用
// console.log(obj.name);
// 导致执行完obj后还存在，因为要用啊
// set可以存任意值，weakset只能存symbol和对象类型
let ws = new WeakSet()
// 垃圾回收机制不看weakset引用这东西，所以obj一定义就被销毁
ws.add(obj)

// 让垃圾回收机制直接销毁他
// obj = null 告诉垃圾回收机制可以扫掉，不是强行
// 上面这行的代码有没有都可以，清洁工不管ws的
console.log(ws);
// 按道理是有的，但是输出是空的，为什么？因为输出ws的时候指向的房间，但是房间已经被清空了（=null） -- 合情合理
// 不是空的根本原因，清洁工在打瞌睡，如果真清理了，一定是空，清洁工清洁的时间你无法掌控。

